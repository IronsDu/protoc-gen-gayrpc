package generator

const CppTemplate = `// Generated by github.com/IronsDu/protoc-gen-gayrpc
// Coding by github.com/liuhan907
// DO NOT EDIT!!!

#ifndef {{$.MacroName}}
#define {{$.MacroName}}

#include <string>
#include <unordered_map>
#include <memory>
#include <cstdint>

#include <google/protobuf/util/json_util.h>

#include "meta.pb.h"
#include "{{$.ModelFileName}}"

#include "GayRpcCore.h"
#include "GayRpcError.h"
#include "GayRpcTypeHandler.h"
#include "GayRpcClient.h"
#include "GayRpcService.h"
#include "GayRpcReply.h"

{{range $i, $packageName := $.PackageNames}}namespace {{$packageName}} {
{{end}}
namespace {{$.Namespace}}
{
	using namespace gayrpc::core;
	using namespace google::protobuf::util;
	
	{{range $i, $service := $.Services}}
	enum class {{$service.MethodsEnumName}}:uint64_t
	{
		{{range $i, $method := $service.Methods}}{{$method.EnumName}} = {{$method.MethodID}},
		{{end}}
	};

	class {{$service.Name}}Client : public BaseClient
	{
	public:
		typedef std::shared_ptr<{{$service.Name}}Client> PTR;

		{{range $i, $method := $service.Methods}}typedef std::function<void(const {{$.ContainerNamespace}}{{$method.OutputType}}&,
			const gayrpc::core::RpcError&)> {{$method.Name}}Handle;
		{{end}}

    public:
		{{range $i, $method := $service.Methods}}void {{$method.MethodName}}(const {{$.ContainerNamespace}}{{$method.InputType}}& request,
			const {{$method.Name}}Handle& handle = nullptr)
		{
			call<{{$.ContainerNamespace}}{{$method.OutputType}}>(request, static_cast<uint64_t>({{$service.MethodsEnumName}}::{{$method.EnumName}}), handle);
		}
		{{end}}

    public:
        static PTR Create(const RpcTypeHandleManager::PTR& rpcHandlerManager,
            const UnaryServerInterceptor& outboundInterceptor,
            const UnaryServerInterceptor& inboundInterceptor)
        {
            struct make_shared_enabler : public {{$service.Name}}Client
            {
            public:
                make_shared_enabler(const UnaryServerInterceptor& outboundInterceptor,
                    const UnaryServerInterceptor& inboundInterceptor)
                    : 
                    {{$service.Name}}Client(outboundInterceptor, inboundInterceptor) {}
            };

            auto client = PTR(new make_shared_enabler(outboundInterceptor, inboundInterceptor));
            client->installResponseStub(rpcHandlerManager);

            return client;
        }

    private:
        using BaseClient::BaseClient;
    };

	{{range $i, $method := $service.Methods}}typedef TemplateReply<{{$.ContainerNamespace}}{{$method.OutputType}}> {{$method.Name}}Reply;
	{{end}}

    class {{$service.Name}}Service : public BaseService
    {
    public:
        typedef std::shared_ptr<{{$service.Name}}Service> PTR;
        virtual ~{{$service.Name}}Service()
        {
        }

        virtual void onClose() {}

    private:
		{{range $i, $method := $service.Methods}}virtual bool {{$method.MethodName}}(const {{$.ContainerNamespace}}{{$method.InputType}}& request, 
            const {{$method.Name}}Reply::PTR& replyObj) = 0;
		{{end}}

    private:
        friend  void register{{$service.Name}}Service(gayrpc::core::RpcTypeHandleManager::PTR rpcTypeHandleManager,
            const {{$service.Name}}Service::PTR& service,
            const UnaryServerInterceptor& inboundInterceptor,
            const UnaryServerInterceptor& outboundInterceptor);

		{{range $i, $method := $service.Methods}}static bool {{$method.MethodName}}_stub(const RpcMeta& meta,
			const std::string& data,
			const {{$service.Name}}Service::PTR& service,
			const UnaryServerInterceptor& inboundInterceptor,
			const UnaryServerInterceptor& outboundInterceptor)
		{
			{{$.ContainerNamespace}}{{$method.InputType}} request;
			if (!request.ParseFromString(data))
			{
			    std::cerr << "parse {{$method.Name}}Requst error " << std::endl;
			    return false;
			}

			inboundInterceptor(meta,
			    request,
			    [service,
			    outboundInterceptor,
			    &request](const RpcMeta& meta, const google::protobuf::Message& message) {
			    auto replyObject = std::make_shared<{{$method.Name}}Reply>(meta, outboundInterceptor);
			    service->{{$method.MethodName}}(request, replyObject);
			});
			return true;
		}
		{{end}}
    };

	inline void register{{$service.Name}}Service(gayrpc::core::RpcTypeHandleManager::PTR rpcTypeHandleManager,
        const {{$service.Name}}Service::PTR& service,
        const UnaryServerInterceptor& inboundInterceptor,
        const UnaryServerInterceptor& outboundInterceptor)
    {
		typedef std::function<bool(const RpcMeta&,
		    const std::string& data,
		    const {{$service.Name}}Service::PTR&,
		    const UnaryServerInterceptor&,
		    const UnaryServerInterceptor&)> {{$service.Name}}ServiceRequestHandler;

		typedef std::unordered_map<uint64_t, {{$service.Name}}ServiceRequestHandler> {{$service.Name}}ServiceHandlerMap;

		auto serviceHandlerMap = std::make_shared<{{$service.Name}}ServiceHandlerMap>();

		{{range $i, $method := $service.Methods}}(*serviceHandlerMap)[static_cast<uint64_t>({{$service.MethodsEnumName}}::{{$method.MethodName}})] = {{$service.Name}}Service::{{$method.MethodName}}_stub;
		{{end}}

		auto requestStub = [service,
		    serviceHandlerMap,
		    inboundInterceptor,
		    outboundInterceptor](const RpcMeta& meta, const std::string& data) {
		    if (meta.type() == RpcMeta::REQUEST)
		    {
		        auto it = serviceHandlerMap->find(meta.request_info().method());
		        if (it == serviceHandlerMap->end())
		        {
		            std::cerr << "not found handle, method:" << meta.request_info().method();
		            return false;
		        }

		        (*it).second(meta,
		            data,
		            service,
		            inboundInterceptor,
		            outboundInterceptor);
		    }
		    return true;
		};
		rpcTypeHandleManager->registerTypeHandle(RpcMeta::REQUEST, requestStub);
	}
	{{end}}
}

{{range $i, $packageName := $.PackageNames}}}
{{end}}
#endif

`
